#!/usr/bin/env python

DOCUMENTATION = """
---
module: mylib_perform_apt_get_update
short_description: Performs `apt-get update` on custom conditions
description:
    - Performs `apt-get update` when the Singapore Ubuntu mirror has been
      replaced or when the last successful `apt-get update` was performed
      `cache_time_valid` seconds ago
author: "Pang Yan Han, Philip (@yanhan_pang)"
notes: []
requirements:
    - Ubuntu Linux
options:
    cache_valid_time:
        description:
            - Minimum number of seconds between last successful
              `apt-get update` and the current time that must be passed for us
              to perform an `apt-get update` if the
              `nr_lines_with_sg_mirror_in_apt_sources` option is less than or
              equal to 0 (meaning that the Singapore Ubuntu mirror has been
              replaced)
        required: False
        default: 0

    nr_line_with_sg_mirror_in_apt_sources:
        description:
            - Number of lines in /etc/apt/sources.list where the
              http://sg.archive.ubuntu.com mirror is used. If this is greater
              than 0, an `apt-get update` will be performed regardless of the
              value of `cache_valid_time`
        required: False
        default: 0
"""

import os
import subprocess
import tempfile
import time

def main():
    module = AnsibleModule(
        argument_spec=dict(
            cache_valid_time                       = dict(required=False, type="int", default=0),
            nr_lines_with_sg_mirror_in_apt_sources = dict(required=False, type="int", default=0),
        )
    )
    params = module.params
    need_to_update = False
    if params["nr_lines_with_sg_mirror_in_apt_sources"] > 0:
        # If the mirrors have just been replaced, we must do an `apt-get update`
        need_to_update = True
    else:
        # No mirrors have been replaced, so we check to see if the last
        # successful `apt-get update` was done at least `cache_valid_time`
        # seconds ago.
        # We will obtain the time where the previous successful `apt-get update`
        # was done using:
        #
        #    `ls --full-time /var/lib/apt/periodic/update-success-stamp`,
        #
        # which will contain the time of last modification of given file, which
        # is roughly the time where the last successful `apt-get update` was
        # performed.

        # Because how Ansible handles stdout and stderr is an unknown to us, to
        # properly capture the standard output of the process we will be
        # spawning, we will need to direct it to a file. `delete=False` is
        # specified here to avoid automatically deleting the file when we close
        # it. So we'll remove it manually later.
        process_stdout_tempfile = tempfile.NamedTemporaryFile(delete=False)
        p = subprocess.Popen(
            ["/bin/ls", "--full-time", "/var/lib/apt/periodic/update-success-stamp"],
            stdout=process_stdout_tempfile
        )
        p.communicate()
        process_stdout_tempfile.close()
        # Read the contents of stdout
        p_stdout = ""
        with open(process_stdout_tempfile.name, "r") as f:
            p_stdout = f.read()
        os.remove(process_stdout_tempfile.name)
        # split the output of `ls --full-time` and obtain the 5th and 6th fields
        # (zero indexed).
        p_stdout_arr = p_stdout.strip().split()
        yyyymmdd, hhmmss = p_stdout_arr[5], p_stdout_arr[6]
        # The 6th field is in "HH:MM:SS.XXXXXXXXX" format on my computer.
        # We discard everything after the seconds since we don't actually need
        # that much precision.
        hhmmss = hhmmss[:hhmmss.index(".")]
        last_successful_apt_get_update_unix_timestamp = time.mktime(
            time.strptime(yyyymmdd + " " + hhmmss, "%Y-%m-%d %H:%M:%S")
        )
        now_unix_timestamp = time.time()
        if now_unix_timestamp - last_successful_apt_get_update_unix_timestamp > params["cache_valid_time"]:
            need_to_update = True

    if need_to_update:
        rc, stdout, stderr = module.run_command("apt-get update")
        module.exit_json(
            changed=True,
            rc=rc,
            stdout=stdout,
            stderr=stderr,
        )
    else:
        module.exit_json(
            changed=False,
        )

from ansible.module_utils.basic import *
if __name__ == "__main__":
    main()
